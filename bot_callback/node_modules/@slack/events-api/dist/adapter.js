'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _lodash = require('lodash.isstring');

var _lodash2 = _interopRequireDefault(_lodash);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _expressMiddleware = require('./express-middleware');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var debug = (0, _debug2.default)('@slack/events-api:adapter');

var SlackEventAdapter = function (_EventEmitter) {
  _inherits(SlackEventAdapter, _EventEmitter);

  function SlackEventAdapter(verificationToken) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, SlackEventAdapter);

    if (!(0, _lodash2.default)(verificationToken)) {
      throw new TypeError('SlackEventAdapter needs a verification token');
    }

    var _this = _possibleConstructorReturn(this, (SlackEventAdapter.__proto__ || Object.getPrototypeOf(SlackEventAdapter)).call(this));

    _this.verificationToken = verificationToken;
    _this.includeBody = !!options.includeBody || false;
    _this.includeHeaders = !!options.includeHeaders || false;
    _this.waitForResponse = !!options.waitForResponse || false;

    debug('adapter instantiated - options: %o', {
      includeBody: _this.includeBody,
      includeHeaders: _this.includeHeaders,
      waitForResponse: _this.waitForResponse
    });
    return _this;
  }

  // TODO: options (like https)


  _createClass(SlackEventAdapter, [{
    key: 'createServer',
    value: function createServer() {
      var _this2 = this;

      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/slack/events';

      // NOTE: this is a workaround for a shortcoming of the System.import() tranform
      return Promise.resolve().then(function () {
        return Promise.all([Promise.resolve(require(('express'))), Promise.resolve(require(('body-parser')))]);
      }).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            express = _ref2[0],
            bodyParser = _ref2[1];

        var app = express();
        app.use(bodyParser.json());
        app.post(path, _this2.expressMiddleware());

        debug('server created - path: %s', path);

        return _http2.default.createServer(app);
      });
    }
  }, {
    key: 'start',
    value: function start(port) {
      var _this3 = this;

      return this.createServer().then(function (server) {
        return new Promise(function (resolve, reject) {
          _this3.server = server;
          server.on('error', reject);
          server.listen(port, function () {
            return resolve(server);
          });
          debug('server started - port: %s', port);
        });
      });
    }
  }, {
    key: 'stop',
    value: function stop() {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (_this4.server) {
          _this4.server.close(function (error) {
            delete _this4.server;
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          });
        } else {
          reject(new Error('SlackEventAdapter cannot stop when it did not start a server'));
        }
      });
    }
  }, {
    key: 'expressMiddleware',
    value: function expressMiddleware() {
      var middlewareOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return (0, _expressMiddleware.createExpressMiddleware)(this, middlewareOptions);
    }
  }]);

  return SlackEventAdapter;
}(_events2.default);

exports.default = SlackEventAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hZGFwdGVyLmpzIl0sIm5hbWVzIjpbImRlYnVnIiwiU2xhY2tFdmVudEFkYXB0ZXIiLCJ2ZXJpZmljYXRpb25Ub2tlbiIsIm9wdGlvbnMiLCJUeXBlRXJyb3IiLCJpbmNsdWRlQm9keSIsImluY2x1ZGVIZWFkZXJzIiwid2FpdEZvclJlc3BvbnNlIiwicGF0aCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImFsbCIsImV4cHJlc3MiLCJib2R5UGFyc2VyIiwiYXBwIiwidXNlIiwianNvbiIsInBvc3QiLCJleHByZXNzTWlkZGxld2FyZSIsImNyZWF0ZVNlcnZlciIsInBvcnQiLCJyZWplY3QiLCJzZXJ2ZXIiLCJvbiIsImxpc3RlbiIsImNsb3NlIiwiZXJyb3IiLCJFcnJvciIsIm1pZGRsZXdhcmVPcHRpb25zIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OztBQUVBLElBQU1BLFFBQVEscUJBQWEsMkJBQWIsQ0FBZDs7SUFFcUJDLGlCOzs7QUFDbkIsNkJBQVlDLGlCQUFaLEVBQTZDO0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUFBOztBQUMzQyxRQUFJLENBQUMsc0JBQVNELGlCQUFULENBQUwsRUFBa0M7QUFDaEMsWUFBTSxJQUFJRSxTQUFKLENBQWMsOENBQWQsQ0FBTjtBQUNEOztBQUgwQzs7QUFPM0MsVUFBS0YsaUJBQUwsR0FBeUJBLGlCQUF6QjtBQUNBLFVBQUtHLFdBQUwsR0FBbUIsQ0FBQyxDQUFDRixRQUFRRSxXQUFWLElBQXlCLEtBQTVDO0FBQ0EsVUFBS0MsY0FBTCxHQUFzQixDQUFDLENBQUNILFFBQVFHLGNBQVYsSUFBNEIsS0FBbEQ7QUFDQSxVQUFLQyxlQUFMLEdBQXVCLENBQUMsQ0FBQ0osUUFBUUksZUFBVixJQUE2QixLQUFwRDs7QUFFQVAsVUFBTSxvQ0FBTixFQUE0QztBQUMxQ0ssbUJBQWEsTUFBS0EsV0FEd0I7QUFFMUNDLHNCQUFnQixNQUFLQSxjQUZxQjtBQUcxQ0MsdUJBQWlCLE1BQUtBO0FBSG9CLEtBQTVDO0FBWjJDO0FBaUI1Qzs7QUFFRDs7Ozs7bUNBQ3FDO0FBQUE7O0FBQUEsVUFBeEJDLElBQXdCLHVFQUFqQixlQUFpQjs7QUFDbkM7QUFDQSxhQUFPQyxRQUFRQyxPQUFSLEdBQWtCQyxJQUFsQixDQUF1QjtBQUFBLGVBQU1GLFFBQVFHLEdBQVIsQ0FBWSwwQkFDaEMsU0FEZ0MsOEJBRWhDLGFBRmdDLElBQVosQ0FBTjtBQUFBLE9BQXZCLEVBWU5ELElBWk0sQ0FZRCxnQkFBMkI7QUFBQTtBQUFBLFlBQXpCRSxPQUF5QjtBQUFBLFlBQWhCQyxVQUFnQjs7QUFDL0IsWUFBTUMsTUFBTUYsU0FBWjtBQUNBRSxZQUFJQyxHQUFKLENBQVFGLFdBQVdHLElBQVgsRUFBUjtBQUNBRixZQUFJRyxJQUFKLENBQVNWLElBQVQsRUFBZSxPQUFLVyxpQkFBTCxFQUFmOztBQUVBbkIsY0FBTSwyQkFBTixFQUFtQ1EsSUFBbkM7O0FBRUEsZUFBTyxlQUFLWSxZQUFMLENBQWtCTCxHQUFsQixDQUFQO0FBQ0QsT0FwQk0sQ0FBUDtBQXFCRDs7OzBCQUVLTSxJLEVBQU07QUFBQTs7QUFDVixhQUFPLEtBQUtELFlBQUwsR0FDSlQsSUFESSxDQUNDO0FBQUEsZUFBVSxJQUFJRixPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVWSxNQUFWLEVBQXFCO0FBQy9DLGlCQUFLQyxNQUFMLEdBQWNBLE1BQWQ7QUFDQUEsaUJBQU9DLEVBQVAsQ0FBVSxPQUFWLEVBQW1CRixNQUFuQjtBQUNBQyxpQkFBT0UsTUFBUCxDQUFjSixJQUFkLEVBQW9CO0FBQUEsbUJBQU1YLFFBQVFhLE1BQVIsQ0FBTjtBQUFBLFdBQXBCO0FBQ0F2QixnQkFBTSwyQkFBTixFQUFtQ3FCLElBQW5DO0FBQ0QsU0FMZSxDQUFWO0FBQUEsT0FERCxDQUFQO0FBT0Q7OzsyQkFFTTtBQUFBOztBQUNMLGFBQU8sSUFBSVosT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVVksTUFBVixFQUFxQjtBQUN0QyxZQUFJLE9BQUtDLE1BQVQsRUFBaUI7QUFDZixpQkFBS0EsTUFBTCxDQUFZRyxLQUFaLENBQWtCLFVBQUNDLEtBQUQsRUFBVztBQUMzQixtQkFBTyxPQUFLSixNQUFaO0FBQ0EsZ0JBQUlJLEtBQUosRUFBVztBQUNUTCxxQkFBT0ssS0FBUDtBQUNELGFBRkQsTUFFTztBQUNMakI7QUFDRDtBQUNGLFdBUEQ7QUFRRCxTQVRELE1BU087QUFDTFksaUJBQU8sSUFBSU0sS0FBSixDQUFVLDhEQUFWLENBQVA7QUFDRDtBQUNGLE9BYk0sQ0FBUDtBQWNEOzs7d0NBRXlDO0FBQUEsVUFBeEJDLGlCQUF3Qix1RUFBSixFQUFJOztBQUN4QyxhQUFPLGdEQUF3QixJQUF4QixFQUE4QkEsaUJBQTlCLENBQVA7QUFDRDs7Ozs7O2tCQTNFa0I1QixpQiIsImZpbGUiOiJhZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xuaW1wb3J0IGh0dHAgZnJvbSAnaHR0cCc7XG5pbXBvcnQgaXNTdHJpbmcgZnJvbSAnbG9kYXNoLmlzc3RyaW5nJztcbmltcG9ydCBkZWJ1Z0ZhY3RvcnkgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgY3JlYXRlRXhwcmVzc01pZGRsZXdhcmUgfSBmcm9tICcuL2V4cHJlc3MtbWlkZGxld2FyZSc7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdAc2xhY2svZXZlbnRzLWFwaTphZGFwdGVyJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNsYWNrRXZlbnRBZGFwdGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IodmVyaWZpY2F0aW9uVG9rZW4sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNTdHJpbmcodmVyaWZpY2F0aW9uVG9rZW4pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTbGFja0V2ZW50QWRhcHRlciBuZWVkcyBhIHZlcmlmaWNhdGlvbiB0b2tlbicpO1xuICAgIH1cblxuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnZlcmlmaWNhdGlvblRva2VuID0gdmVyaWZpY2F0aW9uVG9rZW47XG4gICAgdGhpcy5pbmNsdWRlQm9keSA9ICEhb3B0aW9ucy5pbmNsdWRlQm9keSB8fCBmYWxzZTtcbiAgICB0aGlzLmluY2x1ZGVIZWFkZXJzID0gISFvcHRpb25zLmluY2x1ZGVIZWFkZXJzIHx8IGZhbHNlO1xuICAgIHRoaXMud2FpdEZvclJlc3BvbnNlID0gISFvcHRpb25zLndhaXRGb3JSZXNwb25zZSB8fCBmYWxzZTtcblxuICAgIGRlYnVnKCdhZGFwdGVyIGluc3RhbnRpYXRlZCAtIG9wdGlvbnM6ICVvJywge1xuICAgICAgaW5jbHVkZUJvZHk6IHRoaXMuaW5jbHVkZUJvZHksXG4gICAgICBpbmNsdWRlSGVhZGVyczogdGhpcy5pbmNsdWRlSGVhZGVycyxcbiAgICAgIHdhaXRGb3JSZXNwb25zZTogdGhpcy53YWl0Rm9yUmVzcG9uc2UsXG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPOiBvcHRpb25zIChsaWtlIGh0dHBzKVxuICBjcmVhdGVTZXJ2ZXIocGF0aCA9ICcvc2xhY2svZXZlbnRzJykge1xuICAgIC8vIE5PVEU6IHRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBhIHNob3J0Y29taW5nIG9mIHRoZSBTeXN0ZW0uaW1wb3J0KCkgdHJhbmZvcm1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBQcm9taXNlLmFsbChbXG4gICAgICBTeXN0ZW0uaW1wb3J0KCdleHByZXNzJyksXG4gICAgICBTeXN0ZW0uaW1wb3J0KCdib2R5LXBhcnNlcicpLFxuICAgICAgLy8gaW1wb3J0KCdleHByZXNzJyksXG4gICAgICAvLyBpbXBvcnQoJ2JvZHktcGFyc2VyJyksXG5cbiAgICAgIC8vIFRoZSBwcmV2aW91cyBsaW5lcyBzaG91bGQgYmUgd3JpdHRlbiBhcyB0aGUgY29tbWVudCBmb2xsb3dpbmcgaXQsIHNpbmNlIGBTeXN0ZW0uaW1wb3J0KClgXG4gICAgICAvLyBpcyBnb2luZyB0byBkaXNhcHBlYXIgYWZ0ZXIgZHluYW1pYyBpbXBvcnRzIGxhbmQgKGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWR5bmFtaWMtaW1wb3J0KS5cbiAgICAgIC8vIFRoZXJlIGFyZSBubyBiYWJlbCB0cmFuc2Zvcm1zIGZvciB0aGlzIHN5bnRheCB0aGF0IHNlZW0gdG8gd29yayBhdCB0aGUgbW9tZW50LiBUaGVcbiAgICAgIC8vIGZvbGxvd2luZyB3YXMgbWVhbnQgdG8gd29yayBidXQgZW5kZWQgdXAgbm90IHdvcmtpbmc6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcHdtY2tlbm5hL2JhYmVsLXBsdWdpbi10cmFuc2Zvcm0taW1wb3J0LWNvbW1vbmpzLlxuICAgIF0pKVxuICAgIC50aGVuKChbZXhwcmVzcywgYm9keVBhcnNlcl0pID0+IHtcbiAgICAgIGNvbnN0IGFwcCA9IGV4cHJlc3MoKTtcbiAgICAgIGFwcC51c2UoYm9keVBhcnNlci5qc29uKCkpO1xuICAgICAgYXBwLnBvc3QocGF0aCwgdGhpcy5leHByZXNzTWlkZGxld2FyZSgpKTtcblxuICAgICAgZGVidWcoJ3NlcnZlciBjcmVhdGVkIC0gcGF0aDogJXMnLCBwYXRoKTtcblxuICAgICAgcmV0dXJuIGh0dHAuY3JlYXRlU2VydmVyKGFwcCk7XG4gICAgfSk7XG4gIH1cblxuICBzdGFydChwb3J0KSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlU2VydmVyKClcbiAgICAgIC50aGVuKHNlcnZlciA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICBzZXJ2ZXIub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgc2VydmVyLmxpc3Rlbihwb3J0LCAoKSA9PiByZXNvbHZlKHNlcnZlcikpO1xuICAgICAgICBkZWJ1Zygnc2VydmVyIHN0YXJ0ZWQgLSBwb3J0OiAlcycsIHBvcnQpO1xuICAgICAgfSkpO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2VydmVyKSB7XG4gICAgICAgIHRoaXMuc2VydmVyLmNsb3NlKChlcnJvcikgPT4ge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlcnZlcjtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignU2xhY2tFdmVudEFkYXB0ZXIgY2Fubm90IHN0b3Agd2hlbiBpdCBkaWQgbm90IHN0YXJ0IGEgc2VydmVyJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZXhwcmVzc01pZGRsZXdhcmUobWlkZGxld2FyZU9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVFeHByZXNzTWlkZGxld2FyZSh0aGlzLCBtaWRkbGV3YXJlT3B0aW9ucyk7XG4gIH1cblxufVxuIl19
//# sourceMappingURL=adapter.js.map